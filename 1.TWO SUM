QUESTION NO.1:TWO SUM

my solution(RUNTIME ERROR)
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target) {
    int i,j;
    int* result=malloc(2*sizeof(int));
    
    
    for(i=0;i<numsSize-1;i++)
        for(j=i+1;j<numsSize;j++)
        {
            if(nums[i]>=target) break;
            if((nums[i]+nums[j])==target)
            {
                result[0]=i;
                result[1]=j;
                return result;
            }
        }
        return NULL;
       }
        
        
      AC SOLUTION1:
      Note: The returned array must be malloced, assume caller calls free().
/
int twoSum(int* nums, int numsSize, int target) {

int i,j;
int indices = malloc( 2sizeof(int) );
int max,min;

max = nums[0];
min = nums[0];

for( i=1; i<numsSize; i++ )
{
if( nums[i] > max )
max = nums[i];
if( nums[i] < min )
min = nums[i];
}//找到最大值和最小值max和min

int* repeat_tag = malloc( (max-min+1)*sizeof(int) );//
memset( repeat_tag, 0, (max-min+1)*sizeof(int) ); //初始化repeat_tag

int diff;

for( i=0; i<numsSize; i++ )
{
diff = target-nums[i];

 if( ( diff <= max ) && ( diff >= min ) )//差数在范围内 
     repeat_tag[ diff-min ] = i;
}

for( i=0; i<numsSize; i++ )
{
if( repeat_tag[nums[i]-min] != 0 )
{
// exclude the case in which two indices are the same.
if( i != repeat_tag[nums[i]-min] ) 
{
indices[0] = i;
indices[1] = repeat_tag[nums[i]-min];//
return indices;
}
}
}

return NULL;
}

SOLUTION2:
struct node {

int val;
int index;
};

static int cmp(const void *a, const void *b)
{

return ((struct node *)a)->val - ((struct node *)b)->val;
}

int* twoSum(int* nums, int numsSize, int target) {

int *ret;
struct node *head;
int i,j;
int sum;

ret = (int *)malloc(sizeof(int) * 2);
head = (struct node *)malloc(sizeof(struct node) * numsSize);
for(i = 0; i < numsSize; ++i){
    head[i].index = i + 1;
    head[i].val = nums[i];
}

qsort(head,numsSize,sizeof(struct node),cmp);

i = 0;
j = numsSize - 1;
while(i < j){
    sum = head[i].val + head[j].val;
    if(sum == target){
        ret[0] = head[i].index < head[j].index ? head[i].index : head[j].index;
        ret[1] = head[i].index >= head[j].index ? head[i].index : head[j].index;
        break;
    }else if(sum > target){
        --j;
    }else{
        ++i;
    }
}

return ret;
}
